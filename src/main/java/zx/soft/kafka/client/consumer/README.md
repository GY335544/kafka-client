
## 多线程实现Consumer消费数据的两种方式

> 参考资料： http://kafka.apache.org/090/javadoc/index.html?org/apache/kafka/clients/consumer/KafkaConsumer.html。

### 每个线程一个Consumer

> 最简单的实现思路是每个线程一个Consumer实例，下面是该方法的优缺点：

**优点**

1. 代码实现简单。

2. 速度比较快，因为不需要内部线程调度。

3. 在每个分区上有序处理数据消费（每个线程仅仅处理它所接收的消息）。

**缺点**

1. 更多的消费者意味着更多与Kafka集群的TCP连接数（集群每个线程），不过Kafka处理连接效率很高，所以该缺点可以忽略。

2. 更多的消费者意味着更多的请求发送到服务端，少许较小的批量数据会导致I/O吞吐量降低。

3. 总线程数受分区总数限制。

### 分离消费和处理过程

> 另一个可选的方案是多个消费者线程来处理所有的数据消费和切换ConsumerRecords实例到一个阻塞队列（一个处理线程池来消费该队列，该线程池才是真正消费数据的），下面是该方法的优缺点：

**优点**

1. 可以独立地扩展consumers和processors的数量，这样就可以有一个单独的consumer供给多个processor线程，避免在分区上的任何限制。

**缺点**

1. 在多个processors之间保证顺序是需要尤其注意的是，这些线程可能会执行一个更早的大块数据（这个大块数据可能在稍后的大块数据被处理之后）时，仅仅是由于线程执行需要时间。

2. 手动提交偏移量位置会变得更难，因为需要所有线程协调一致确保分区处理完成。

> 该方法可以衍生出很多版本。例如：每个processor线程可以有它自己的队列，并且consumer线程可以基于TopicPartition通过Hash来对应到这些队列，有序消费和简化提交。
